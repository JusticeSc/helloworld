## Explain

1. table: explain语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名

2. id: 每出现一个select关键字就会被分配一个id值。在连接查询中会出现每个被查询的表都有其对应的记录但其id值相同，出现在前面的表是驱动表，后面的表是被驱动表。在子查询中各个记录的id值可能不同，但也可能相同，因为优化器会将子查询优化为连接查询

3. select_type: 每个select关键字代表的查询的类型

   3.1 simple: 不包含子查询的单表或连接查询

   3.2 primary: 包含子查询的大查询中最左边的查询

   3.3 subquery: 未被转化为连接查询的不相关子查询，其查询结果集会被物化为内存中的临时表，内存中可以使用hash索引

   3.4: dependent subquery: 相关子查询，外部查询每处理一行就执行一遍子查询，可以尝试用join和派生表或窗口函数来重写查询语句优化效率。

   3.5: derived: 当一个子查询被用于from子句，其结果集被物化为派生表或者说临时表，该子查询的类型就是drived，外层查询会像对待普通表一样使用派生表，内存中可以使用hash索引，如果临时表过大仍要落盘到磁盘中，仍使用B+树索引。

   3.6: materialized: 子查询物化后又被优化为连接查询，子查询类型为materialized

4. partitions:略

5. type: 对表执行查询的访问方法类型
   5.1 const: 使用唯一索引等值匹配
   5.2 eq_ref: 连接查询时被驱动表使用唯一索引等值匹配
   5.3 ref: 使用非唯一索引进行等值匹配
   5.4 ref_or_null：使用二级索引进行等值匹配查询且索引值可为null
   5.5 index_merge: 分别扫描各个索引将结果集合并起来或者取交集，范围查询时也可能采用排序合并，可以建立联合索引优化
   5.6 unique_subquery: 类似于eq_ref,in子查询转化为exists子查询，在子查询中使用唯一索引进行等值匹配
   5.7 index_subquery: 类似于unique_subquery,在子查询中使用二级索引进行等值匹配
   5.8 range: 适用于范围查询，快速找到起始记录然后顺序扫描
   5.9 index: 全索引扫描
   5.10 all: 全表扫描

6. possible_keys and key: 可能用到的索引和实际用到的索引，可能用到的索引越多查询优化器计算查询成本花费的时间越多，可以的话应该尽量删除用不到的索引。使用覆盖索引时possible_keys为空但key有值。

7. key_len: 使用的索引的最大长度

8. ref: 使用索引列等值匹配查询时匹配对象的类型，取值为const即比较的是一个字面量常量，取值为数据库名.表名.列名即比较的是另一个表中的列值，取值为func即比较的是函数结果，取值为表达式即比较的是表达式结果

9. rows: 索引优化器预计扫描的行数，对于被驱动表就是预估的平均扇出比

10. filtered: 预估获取了rows行后再过滤后最终保留的记录占比，如果高rows低filtered需要警惕，可以尝试优化索引减少需要处理的记录数。

11. extra: 额外信息说明，比如索引条件下推